<?xml version="1.0" encoding="ISO-8859-1"?>
<chapter id="reverseengineering">
  <title>Controlling reverse engineering</title>

  <para>When using the &lt;jdbcconfiguration&gt; the ant task will read the
  database metadata and from that perform a reverse engineering of the
  database schema into a normal Hibernate Configuration. It is from this
  object e.g. &gt;hbm2java&lt; can generate other artifacts such as .java,
  .hbm.xml etc.</para>

  <para>To govern this process Hibernate uses a reverse engineering strategy.
  A reverse engineering strategy is mainly called to provide more java like
  names for tables, column and foreignkeys into classes, properties and
  associations. It also used to provide mappings from SQL types to Hibernate
  types. The strategy can be customized by the user. The user can even provide
  its own custom reverse engineering strategy if the provided strategy is not
  enough, or simply just provide a small part of the strategy and delegate the
  rest to the default strategy.</para>

  <section>
    <title>Default reverse engineering strategy</title>

    <para>The default strategy uses some rules for mapping JDBC artifact names
    to java artifact names. It also provide basic typemappings from JDBC types
    to Hibernate types. It is the default strategy that uses the packagename
    attribute to convert a table name to a fully qualified classname.</para>
  </section>

  <section id="hibernaterevengxmlfile">
    <title>hibernate.reveng.xml file</title>

    <para>To have fine control over the process a hibernate.reveng.xml file
    can be provided. In this file you can specify type mappings and table
    filtering. This file can be created by hand (its just basic XML) or you
    can use the Hibernate plugins which have a specialized editor.</para>

    <para>Note: many databases is case-sensitive with their names and thus if
    you cannot make some table match and you are sure it is not excluded by a
    &lt;table-filter&gt; then check if the case matches; most databases stores
    table names in uppercase.</para>

    <para>The following is an example of a reveng.xml. Following the example
    is more details about the format.</para>

    <programlisting><![CDATA[<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-reverse-engineering 
  SYSTEM "http://hibernate.sourceforge.net/hibernate-reverse-engineering-3.0.dtd" >

<hibernate-reverse-engineering>

<type-mapping>
 <!-- jdbc-type is name fom java.sql.Types -->
 <sql-type jdbc-type="VARCHAR" length='20' hibernate-type="SomeUserType" /> 
 <sql-type jdbc-type="VARCHAR" length='1' hibernate-type="yes_no" />
 <!-- length, scale and precision can be used to specify the mapping precisly -->
 <sql-type jdbc-type="NUMERIC"  precision='1' hibernate-type="boolean" /> 
 <!-- the type-mappings are ordered. This mapping will be consulted last, 
  thus overriden by the previous one if precision=1 for the column -->
 <sql-type jdbc-type="NUMERIC"  hibernate-type="long" /> 
</type-mapping>

<!-- BIN$ is recycle bin tables in Oracle -->
<table-filter match-name="BIN$.*" exclude="true" /> 

<!-- Exclude DoNotWantIt from all catalogs/schemas -->
<table-filter match-name="DoNotWantIt" exclude="true" /> 

<!-- exclude all tables from the schema SCHEMA in catalog BAD. -->
<table-filter match-catalog="BAD" match-schema="SCHEMA" match-name=".*" exclude="true" /> 

<!-- table allows you to override/define how reverse engineering 
     are done for a specific table -->
<table name="ORDERS"> 
 <primary-key>
   <!-- setting up a specific id generator for a table -->
  <generator class="sequence">
    <param name="table">seq_table</param>
  </generator>
   <key-column name="CUSTID"/>
 </primary-key>
 <column name="NAME" property="orderName" type="string" />
 <!-- control many-to-one and set names for a specific named foreign key constraint -->
 <foreign-key constraint-name="ORDER_CUST">
   <many-to-one property="customer"/>
   <set property="orders"/>
 </foreign-key>
</table>

</hibernate-reverse-engineering>]]></programlisting>

    <para></para>

    <section>
      <title>Schema Selection (&lt;schema-selection&gt;)</title>

      <para><literal>&lt;schema-selection&gt;</literal> is used to drive which
      schema's the reverse engineering will try and process.</para>

      <para>By default the reverse engineering will read all schemas and then
      use <literal>&lt;table-filter&gt;</literal> to decide which tables get
      reverse engineered and which do not; this makes it easy to get started
      but can be inefficient on databases with many schemas.</para>

      <para>With <literal>&lt;schema-selection&gt;</literal> it is thus
      possible to limit the actual processed schemas and thus significantly
      speed-up the reverse engineering.
      <literal>&lt;table-filter&gt;</literal> is still used to then decide
      which tables will be included/excluded.</para>

      <para>Note: If no <literal>&lt;schema-selection&gt;</literal> is
      specified, the reverse engineering works as if all schemas should be
      processed. This is equal to:</para>

      <programlisting><![CDATA[<schema-selection/>]]></programlisting>

      <para>which in turn is equal to:</para>

      <programlisting><![CDATA[<schema-selection match-catalog=".*" match-schema=".*" match-table=".*"/>]]></programlisting>

      <section>
        <title>Examples</title>

        <para>The following will process all tables from MY_SCHEMA.</para>

        <programlisting><![CDATA[<schema-selection match-schema="MY_SCHEMA"/>]]></programlisting>

        <para>It is possible to have multiple
        <literal>schema-selection</literal>'s to support multi-schema reading
        or simply to limit the processing to very specific tables. The
        following example process all tables in MY_SCHEMA, a specific CITY
        table plus all tables that starts with CODES_ in COMMON_SCHEMA.</para>

        <programlisting><![CDATA[<schema-selection match-schema="MY_SCHEMA"/>
<schema-selection match-schema="COMMON_SCHEMA" match-table="CITY"/>
<schema-selection match-schema="COMMON_SCHEMA" match-table="CODES_.*"/>]]></programlisting>
      </section>
    </section>

    <section>
      <title>Type mappings (&lt;type-mapping&gt;)</title>

      <para>The <literal>&lt;type-mapping&gt;</literal> section specifies how
      the JDBC types found in the database should be mapped to Hibernate
      types. e.g. java.sql.Types.VARCHAR with a length of 1 should be mapped
      to the Hibernate type <literal>yes_no</literal> or
      java.sql.Types.NUMERIC should generally just be converted to the
      Hibernate type <literal>long</literal>.</para>

      <programlisting><![CDATA[<type-mapping>
 <sql-type
  jdbc-type="integer value or name from java.sql.Types"
  length="a numeric value"
  precision="a numeric value"
  scale="a numeric value"
  not-null="true|false"  
  hibernate-type="hibernate type name"  
 />
</type-mapping>]]></programlisting>

      <para>The number of attributes specificed and the sequence of the
      <literal>sql-type</literal>'s is important. Meaning that Hibernate will
      search for the most specific first, and if no specific match is found it
      will seek from top to bottom when trying to resolve a type
      mapping.</para>

      <section>
        <title>Example</title>

        <para>The following is an example of a type-mapping which shows the
        flexibility and the importance of ordering of the type
        mappings.</para>

        <programlisting><![CDATA[<type-mapping>
 <sql-type jdbc-type="NUMERIC" precision="15" hibernate-type="big_decimal"/>
 <sql-type jdbc-type="NUMERIC" not-null="true" hibernate-type="long" />
 <sql-type jdbc-type="NUMERIC" not-null="false" hibernate-type="java.lang.Long" />
 <sql-type jdbc-type="VARCHAR" length="1" not-null="true" hibernate-type="java.lang.Character"/>
 <sql-type jdbc-type="VARCHAR" hibernate-type="your.package.TrimStringUserType"/>
 <sql-type jdbc-type="VARCHAR" length="1" hibernate-type="char"/>
 <sql-type jdbc-type="VARCHAR" hibernate-type="string"/>
</type-mapping>]]></programlisting>

        <para>The following table shows how this affects an example table
        named CUSTOMER:</para>

        <table frame="topbot">
          <title>sql-type examples</title>

          <tgroup cols="7">
            <colspec colwidth="0.5*" />

            <colspec colwidth="0.5*" />

            <colspec colwidth="0.2*" />

            <colspec colwidth="0.2*" />

            <colspec colwidth="0.2*" />

            <colspec colwidth="0.5*" />

            <colspec colwidth="1.0*" />

            <thead>
              <row>
                <entry>Column</entry>

                <entry>jdbc-type</entry>

                <entry>length</entry>

                <entry>precision</entry>

                <entry>not-null</entry>

                <entry>Resulting hibernate-type</entry>

                <entry>Rationale</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>ID</entry>

                <entry>INTEGER</entry>

                <entry></entry>

                <entry>10</entry>

                <entry>true</entry>

                <entry>int</entry>

                <entry>Nothing defined for INTEGER. Falling back to default
                behavior.</entry>
              </row>

              <row>
                <entry>NAME</entry>

                <entry>VARCHAR</entry>

                <entry>30</entry>

                <entry></entry>

                <entry>false</entry>

                <entry>your.package.TrimStringUserType</entry>

                <entry>No type-mapping matches length=30 and not-null=false,
                but type-mapping matches the 2 mappings which only specifies
                VARCHAR. The type-mapping that comes first is chosen.</entry>
              </row>

              <row>
                <entry>INITIAL</entry>

                <entry>VARCHAR</entry>

                <entry>1</entry>

                <entry></entry>

                <entry>false</entry>

                <entry>char</entry>

                <entry>Even though there is a generic match for VARCHAR, the
                more specifc type-mapping for VARCHAR with not-null="false" is
                chosen. The first VARCHAR sql-type matches in length but has
                no value for not-null and thus is not considered.</entry>
              </row>

              <row>
                <entry>CODE</entry>

                <entry>VARCHAR</entry>

                <entry>1</entry>

                <entry></entry>

                <entry>true</entry>

                <entry>java.lang.Character</entry>

                <entry>The most specific VARCHAR with not-null="true" is
                selected.</entry>
              </row>

              <row>
                <entry>SALARY</entry>

                <entry>NUMERIC</entry>

                <entry></entry>

                <entry>15</entry>

                <entry>false</entry>

                <entry>big_decimal</entry>

                <entry>There is a precise match for NUMERIC with precision
                15</entry>
              </row>

              <row>
                <entry>AGE</entry>

                <entry>NUMERIC</entry>

                <entry></entry>

                <entry>3</entry>

                <entry>false</entry>

                <entry>java.lang.Long</entry>

                <entry>type-mapping for NUMERIC with not-null="false"</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para></para>
      </section>
    </section>

    <section>
      <title>Table filters (&lt;table-filter&gt;)</title>

      <para>The &lt;table-filter&gt; let you specifcy matching rules for
      performing general filtering/setup for tables, e.g. let you include or
      exclude specific tables based on the schema or even a specifc
      prefix.</para>

      <programlistingco>
        <areaspec>
          <area coords="2 55" id="tablefilter-matchcatalog" />

          <area coords="3 55" id="tablefilter-matchschema" />

          <area coords="4 55" id="tablefilter-matchname" />

          <area coords="5 55" id="tablefilter-exclude" />

          <area coords="6 55" id="tablefilter-package" />
        </areaspec>

        <programlisting><![CDATA[<table-filter
 match-catalog="catalog_matching_rule"
 match-schema="schema_matching_rule"
 match-name="table_matching_rule"
 exclude="true|false"
 package="package.name"
/>]]></programlisting>

        <calloutlist>
          <callout arearefs="tablefilter-matchcatalog">
            <para>match-catalog (default: .*): Pattern for matching catalog
            part of the table</para>
          </callout>

          <callout arearefs="tablefilter-matchschema">
            <para>match-schema (default: .*): Pattern for matching schema part
            of the table</para>
          </callout>

          <callout arearefs="tablefilter-matchname">
            <para>match-table (default: .*): Pattern for matching table part
            of the table</para>
          </callout>

          <callout arearefs="tablefilter-exclude">
            <para>exclude (default: false): if true the table will not be part
            of the reverse engineering</para>
          </callout>

          <callout arearefs="tablefilter-package">
            <para>package (default: ""): The default package name to use for
            classes based on tables matched by this table-filter</para>
          </callout>
        </calloutlist>
      </programlistingco>
    </section>

    <section>
      <title>Specific table configuration (&lt;table&gt;)</title>

      <para><literal>&lt;table&gt;</literal> allows you to provide explicit
      configuration on how a table should be reverse engineered. Amongst other
      things it allow control over the naming of a class for the table,
      specify which identifier generator should be used for the primary key
      etc.</para>

      <programlistingco>
        <areaspec>
          <area coords="2 55" id="table-catalog" />

          <area coords="3 55" id="table-schema" />

          <area coords="4 55" id="table-name" />

          <area coords="5 55" id="table-class" />
        </areaspec>

        <programlisting><![CDATA[<table 
 catalog="catalog_name"
 schema="schema_name"
 name="table_name"
 class="ClassName"
>
 <primary-key.../>
 <column.../>
 <foreign-key.../>
</table>]]></programlisting>

        <calloutlist>
          <callout arearefs="tablefilter-matchcatalog">
            <para>catalog (Optional): Catalog name for table. Has to be specified if you are reverse engineering multiple catalogs or if it is not equal to <literal>hiberante.default_catalog</literal></para>
          </callout>

          <callout arearefs="tablefilter-matchschema">
            <para>schema (Optional): Schema name for table. Has to be specified if you are reverse engineering multiple schemas or if it is not equal to <literal>hiberante.default_schema</literal></para>
          </callout>

          <callout arearefs="tablefilter-matchname">
            <para>name (Required): Name for table</para>
          </callout>

          <callout arearefs="tablefilter-exclude">
            <para>clase (Optional): The class name for table. Default name is
            camelcase version of the table name.</para>
          </callout>
        </calloutlist>
      </programlistingco>

      <section>
        <title>&lt;primary-key&gt;</title>

        <para>A <literal>&lt;primary-key&gt;</literal> allows you to define a
        primary-key for tables that does not have such defined in the
        database, and probably more importantly it allows you to define which
        identifier strategy that should be used (even for already existing
        primary-key's).</para>

        <programlistingco>
          <areaspec>
            <area coords="2 55" id="pk-generatorclass" />

            <area coords="3 55" id="pk-generatorparam" />

            <area coords="5 55" id="pk-keycolumn" />
          </areaspec>

          <programlisting><![CDATA[<primary-key
 <generator class="generatorname">
   <param name="param_name">parameter value</param>
 </generator>
 <key-column...>
</primary-key>]]></programlisting>

          <calloutlist>
            <callout arearefs="pk-generatorclass">
              <para>generator/class (Optional): defines which identifier
              generator should be used. The class name is any hibernate short
              hand name or fully quailfied class name for an identifier
              strategy.</para>
            </callout>

            <callout arearefs="pk-generatorparam">
              <para>generator/param (Optional): Allows to specify which
              parameter with name and value should be passed to the identifier
              generator</para>
            </callout>

            <callout arearefs="pk-keycolumn">
              <para>key-column (Optional): Specifies which column(s ) the
              primary-key consists of. A key-column is same as column, but
              does not have the exclude property.</para>
            </callout>
          </calloutlist>
        </programlistingco>
      </section>

      <section>
        <title>&lt;column&gt;</title>

        <para>With a &lt;column&gt; it is possible to explicitly name the
        resulting property for a column. It is also possible to redefine what
        jdbc and/or hibernate type a column should be processed and finally it
        is possible to completely exclude a column from processing.</para>

        <para><programlistingco>
            <areaspec>
              <area coords="2 55" id="column-name" />

              <area coords="3 55" id="column-jdbctype" />

              <area coords="4 55" id="column-type" />

              <area coords="5 55" id="column-propertytype" />

              <area coords="6 55" id="column-exclude" />
            </areaspec>

            <programlisting><![CDATA[<column
 name="column_name"
 jdbc-type="java.sql.Types type"
 type="hibernate_type"
 property="propertyName"
 exclude="true|false"
/>]]></programlisting>

            <calloutlist>
              <callout arearefs="column-name">
                <para>name (Required): Column name</para>
              </callout>

              <callout arearefs="column-jdbctype">
                <para>jdbc-type (Optional): Which jdbc-type this column should
                be processed as. A value from java.sql.Types, either numerical
                (93) or the constant name (TIMESTAMP).</para>
              </callout>

              <callout arearefs="column-type">
                <para>type (Optional): Which hibernate-type to use for this
                specific column.</para>
              </callout>

              <callout arearefs="column-propertytype">
                <para>property (Optional): What property name will be
                generated for this column.</para>
              </callout>

              <callout arearefs="column-exclude">
                <para>exclude (default: false): set to true if this column
                should be ignored.</para>
              </callout>
            </calloutlist>
          </programlistingco></para>
      </section>

      <section>
        <title>&lt;foreign-key&gt;</title>

        <para>The &lt;foreign-key&gt; has two purposes. One for allowing to
        define foreign-keys in databases that does not support them or does
        not have them defined in their schema. Secondly, to allow defining the
        name of the resulting properties (many-to-one and
        one-to-many's).</para>

        <para>Note</para>

        <para><programlistingco>
            <areaspec>
              <area coords="2 55" id="foreignkey-name" />

              <area coords="3 55" id="foreignkey-catalog" />

              <area coords="4 55" id="foreignkey-schema" />

              <area coords="5 55" id="foreignkey-table" />

              <area coords="7 55" id="foreignkey-columnref" />

              <area coords="8 55" id="foreignkey-manytoone" />

              <area coords="10 55" id="foreignkey-set" />
            </areaspec>

            <programlisting><![CDATA[<foreign-key
  constraint-name="foreignKeyName"
  foreign-catalog="catalogName"
  foreign-schema="schemaName"
  foreign-table="tableName"
 >
 <column-ref local-column="columnName" foreign-column="foreignColumnName"/>
 <many-to-one 
   property="aPropertyName"
   exclude="true|false"/>
 <set 
   property="aCollectionName"
   exclude="true|false"/>
</foreign-key>]]></programlisting>

            <calloutlist>
              <callout arearefs="foreignkey-name">
                <para>constraint-name (Required): Name of the foreign key
                constraint. Important when naming many-to-one and set. It is
                the constraint-name that is used to link the processed
                foreign-keys with the resulting property names.</para>
              </callout>

              <callout arearefs="foreignkey-catalog">
                <para>foreign-catalog (Optional): Name of the foreign table's
                catalog. (Only relevant if you want to explicitly define a
                foreign key)</para>
              </callout>

              <callout arearefs="foreignkey-schema">
                <para>foreign-schema (Optional): Name of the foreign table's
                schema. (Only relevant if you want to explicitly define a
                foreign key)</para>
              </callout>

              <callout arearefs="foreignkey-table">
                <para>foreign-table (Optional): Name of the foreign table.
                (Only relevant if you want to explicitly define a foreign
                key)</para>
              </callout>

              <callout arearefs="foreignkey-columnref">
                <para>column-ref (Optional): Defines that the foreign-key
                constraint between a local-column and foreign-column name.
                (Only relevant if you want to explicitly define a foreign
                key)</para>
              </callout>

              <callout arearefs="foreignkey-manytoone">
                <para>many-to-one (Optional): Defines that a many-to-one
                should be created and the property attribute specifies the
                name of the resulting property. Exclude can be used to
                explicitly define that it should be created or not.</para>
              </callout>

              <callout arearefs="foreignkey-set">
                <para>set (Optional): Defines that a set should be created
                based on this foreign-key and the property attribute specifies
                the name of the resulting (set) property. Exclude can be used
                to explicitly define that it should be created or not.</para>
              </callout>
            </calloutlist>
          </programlistingco></para>
      </section>
    </section>
  </section>

  <section id="custom-reveng-strategy">
    <title>Custom strategy</title>

    <para>It is possible to implement a user strategy. Such strategy must
    implement org.hibernate.cfg.reveng.ReverseEngineeringStrategy. It is
    recommended that one uses the DelegatingReverseEngineeringStrategy and
    provide a public constructor which takes another
    ReverseEngineeringStrategy as argument. This will allow you to only
    implement the relevant methods and provide a fallback strategy. Example of
    custom delegating strategy which converts all column names that ends with
    "PK" into a property named "id".</para>

    <para></para>

    <programlisting><![CDATA[public class ExampleStrategy extends DelegatingReverseEngineeringStrategy {

 public ExampleStrategy(ReverseEngineeringStrategy delegate) {
  super(delegate);
 }

 public String columnToPropertyName(TableIdentifier table, String column) {
  if(column.endsWith("PK")) {
   return "id";
  } else {
   return super.columnToPropertyName(table, column);
  }
 }
}]]></programlisting>
  </section>

  <section>
    <title>Custom Database Metadata</title>

    <para>By default the reverse engineering is performed by reading using the
    JDBC database metadata API. This is done via the class
    <literal>org.hibernate.cfg.reveng.dialect.JDBCMetaDataDialect</literal>
    which is an implementation of
    <literal>org.hibernate.cfg.reveng.dialect.MetaDataDialect</literal>.</para>

    <para>The default implementation can be replaced with an alternative
    implementation by setting the property
    <literal>hibernatetool.metadatadialect</literal> to a fully qualified
    classname for a class that implements
    <literal>JDBCMetaDataDialect</literal>.</para>

    <para>This can be used to provide database specific optimized metadata
    reading. If you create an optimized/better metadata reading for your
    database it will be a very welcome contribution.</para>
  </section>
</chapter>
<?xml version="1.0" encoding="UTF-8"?>
<chapter id="Test_Drive_Proc_Development" xreflabel="Test_Drive_Proc_Development">
    <?dbhtml filename="Test_Drive_Proc_Development.html"?>
    <chapterinfo>
        <keywordset>
            <keyword>jBPM</keyword>
            <keyword/>
            <keyword/>
            <keyword/>
            <keyword/>
        </keywordset>
    </chapterinfo>
    <title>Test Driven Process Development</title>
    
    <para> One of the most important advantages of JBoss jBPM&apos;s lightweight approach to BPM
        and workflow management is that developers can easily leverage their usual programming
        skills and techniques. One of these well-known techniques is Unit Testing and Test Driven
        Development. </para>
       <para>In this chapter we will show how developers, making use of the JBoss jBPM GPD,
        can use a technique we have baptized <property>Test Driven Process Development</property> to
        create process definitions and test their correctness. </para>

    <para> When creating the <emphasis>
            <property>HellojBPM</property>
        </emphasis> project the create process project wizard has already put in place all the
        library requirements we need to start writing jBPM unit tests. These are contained in the
        jBPM Library container and the most important of it is the <emphasis>
            <property>.jar</property>
        </emphasis> file containing the core jBPM classes. It must be noted that it is possible to
        change the location of the core jBPM installation by changing the preference settings. More
        on this later in the book. </para>

    <para> With that extra knowledge on the project settings, you can create your first test. To do
        this, we create the <emphasis>
            <property>com.jbay</property>
        </emphasis> package in the <emphasis>
            <property>test/java</property>
        </emphasis> source folder. Then we bring up the context menu on this package and select <emphasis>
            <property>New &gt; Other...</property>
        </emphasis> and then <emphasis>
            <property>Java &gt; JUnite &gt; JUnite Test Case</property></emphasis>.</para>

    <figure>
        <title>Create a Test</title>

        <mediaobject>
            <imageobject>
                <imagedata fileref="images/Test_Drive_Proc/test_driv_proc_1.png"/>
            </imageobject>
        </mediaobject>
    </figure>

    <para>We call the test class <emphasis>
            <property>HelloTest</property>
        </emphasis>.</para>

    <figure>
        <title>Create Test Dialog</title>

        <mediaobject>
            <imageobject>
                <imagedata fileref="images/Test_Drive_Proc/test_driv_proc_2.png"/>
            </imageobject>
        </mediaobject>
    </figure>

    <para> We write a simple test scenario as shown on the next figure. Let&apos;s study the
    code of this testcase. </para>
    
    <figure>
        <title>A First Test Scenario</title>
        
        <mediaobject>
            <imageobject>
                <imagedata fileref="images/Test_Drive_Proc/test_driv_proc_3.png" scale="75"/>
            </imageobject>
        </mediaobject>
    </figure>
        
        <para>In the first line of the method, a jBPM process archive object is
        created. We use a constructor accepting the filename of the archive. In our case it is the
            <emphasis>
                <property>hello</property></emphasis> file we created earlier and which lives in the
            <emphasis>
                <property>src/main/jpdl</property></emphasis> folder of our project. After asserting that this object is really
        created, we extract a process definition object from it. This object is fed to the
        constructor of a process instance object. We have a process instance object, but this
        process is not yet started, so we can safely assert that its root token still resides in the
        start node. After signalling the token will move to the next state and the process will be
        in the   <emphasis><property>auction</property></emphasis> state. Finally another signal will end the process. </para>

   
    <para> After writing this test we can check whether it works as expected by running it .</para>

    <figure>
        <title>Running the Process Test</title>

        <mediaobject>
            <imageobject>
                <imagedata fileref="images/Test_Drive_Proc/test_driv_proc_4.png" scale="75"/>
            </imageobject>
        </mediaobject>
    </figure>
    <para>All went well as we have a green light:</para>

    <figure>
        <title>Successful Test Run</title>

        <mediaobject>
            <imageobject>
                <imagedata fileref="images/Test_Drive_Proc/test_driv_proc_5.png" scale="75"/>
            </imageobject>
        </mediaobject>
    </figure>
    
    <para> Of course, this simple scenario was not very interesting, but the purpose of it was to
        show how you can reuse your development skills in a very straightforward way when doing
        process development. To see how more interesting processes and process test
        scenario&apos;s can be developed, we suggest you to read the <property>JBoss jBPM User
            Guide</property> and to study the API reference. Moreover some more examples will be
        given later in this book.</para>

</chapter>

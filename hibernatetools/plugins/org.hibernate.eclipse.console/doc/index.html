<html>
<head>
<title>Hibernate3 Tools</title>
<style type="text/css" media="screen">
<!--
  body {
    font-family: Sans-serif, Arial, Helvetica;
  }

  pre, tt {
    font-size: 90%;
    font-family: monospace;
    color: #000000;
  }

  .code {
    font-size: 95%;
    font-family: monospace;
    padding: 5px;
    border-style: solid;
    border-width: 1px;
    border-color: #CCCCCC;
    background-color: #eeeeee;
  }

  #toc {
    float: right;
    font-size: 80%;
    border: 1px solid #CCCCCC;
    margin: 0px 0px 20px 20px;
    padding: 5px;
    background: #eeeeee;
  }
  #toc .level2 { margin-left: 1em; }
  #toc .level3 { margin-left: 2em; }
  #toc .level4 { margin-left: 3em; }
  #toc .level5 { margin-left: 4em; }
  #toc .level6 { margin-left: 5em; }

-->
</style>
<script><!--
function H_getText(el) {
  return el.firstChild.data;
}
function TOC_EL(el, text, level) {
  this.element = el;
  this.text = text;
  this.level = level;
}
function getHeadlines(el) {
  var l = new Array;
  var rx = /[hH]([1-6])/;
  // internal recursive function that scans the DOM tree
  var rec = function (el) {
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
        if (rx.exec(i.tagName))
          l[l.length] = new TOC_EL(i, H_getText(i), parseInt(RegExp.$1));
        rec(i);
      }
    }
  }
  rec(el);
  return l;
}
function generate_TOC(parentElementId) {
  var parent = document.getElementById(parentElementId);
  var hs = getHeadlines(document.getElementsByTagName("body")[0]);
  for (var i = 0; i < hs.length; ++i) {
    var hi = hs[i];
    var d = document.createElement("div");
    if (hi.element.id == "")
      hi.element.id = "gen" + i;
    var a = document.createElement("a");
    a.href = "#" + hi.element.id;
    a.appendChild(document.createTextNode(hi.text));
    d.appendChild(a);
    d.className = "level" + hi.level;
    parent.appendChild(d);
  }
}
// --></script>
</head>

<body onload="generate_TOC('toc')">

<h1>Hibernate Tools</h1>
<b><big>Reverse engineering and code generation with Eclipse plugins and a hbm.xml editor</b></big>
<br/>
<br/>
<b>Version:</b> 3.0 alpha, xx. January 2005

<hr>

<div id="toc"></div>

<p><i>Please note that this release is an alpha release and as such is
provided for allowing users to see what has been done on the Hibernate
Tools for Hibernate 3.  This release primarily focus on showing the
eclipse plugins and its integration with the reverse engineering and
code generation. The code and reverse engineering will also be made
available as Ant tasks to allow running them standalone and as part of a build.

  <br><br>See the <a href="http://www.hibernate.org/52.html">Hibernate
Tools Road Map</a> for info about where the tools are heading.</i></p>

<h2>1. Introduction</h2>

<p>
This release contains a set of Eclipse plugins that provides the following
functionality:

  <ul>
    <li>hbm.xml Editor</li>
      <ul>
      <li> semantic class name and property/field completion</li>
      </ul>
        
    <li>Hibernate Console perspective with</li>
      <ul>
       <li>Tree overview of console configurations</li>
       <li>Navigation of mapped class and their structure</li>
       <li>Basic HQL Editor</li>
       <li>Query result view</li>
      </ul>
   <li>Wizards for:</li>
     <ul>
       <li>Quick generation of hibernate.cfg.xml </li>
       <li>Reverse engineering from JDBC</li>
       <li>Generating code artifacts (.java,.hbm.xml & .cfg.xml) based on templates</li>
     </ul>
   </ul>

<h2>2. Requirements</h2>

<p>
  <ol>
    <li>Install Eclipse 3.1M4</li>
    <li>Install JBoss IDE 1.4.x to use the hbm.xml editor</li>
      <li>Download hibernate eclipse plugins 3.0.0.alpha and put the plugins in your favorite plugins directory</li>
      </ol>

You will also need JDBC drivers for your database to use the reverse engineering and querying. 
</p>

<p>
  Please note that these tools does not try to hide any functionality
  of Hibernate. It's goal is to ease some of the tasks that is
  connected with using a ORM such as Hibernate. Users are still
  encourage/required to read the documentation for Hibernate to fully
  utilize Hibernate and it's tools.
</p>

<h2>3. Creating hibernate.cfg.xml</h2>

  <p>
    To be able to reverse engineer, prototype queries and of course to
    simply use Hibernate a hibernate.properties or hibernate.cfg.xml
    file is needed. Hibernate Tools provide a wizard for generating
    the hibernate.cfg.xml.
  </p>

  <p>
    The wizard can be started by clicking "New Wizard" (Ctrl+N), selecting the Hibernate/Hibernate Configuration file (cfg.xml) wizard and press "Next".
    After starting the wizard and you have selected a location for the hibernate.cfg.xml you will see the following page: 
  </p>
  <img src="hibernatecfgwizard.jpg"/>
  <br><b>Figure 1: Creating hibernate.cfg.xml</b></br><br>

    <p>
      On this page you enter the information that is placed in the
      hibernate.cfg.xml. Details about these can be found in Hibernate
      reference documentation.<br>
      Pressing Finish will generate the hibernate.cfg.xml and the file is opened up in a editor.
    </p>

    <p>
      Tip: The contents in the comboboxes for Driver class
      changes dependent on which Dialect you have chosen. The same is
      done for Connection URL dependent on the chosen Driver. 
    </p>

<h2>4. hbm.xml editor</h2>

<p>
The hbm.xml editor provides basic XML editing functionallity, and
furthermore provides package, class and field completion for
relevant attributes. The completion notices it's context and limits the completion for e.g.
&lt;property&gt; and only shows the properties/fields available in the
  enclosing &lt;class&gt;, &lt;subclass&gt; etc. <br>

  <img src="hbmxmlcompletion.jpg"/>
  <br><b>Figure 1: Context dependent code completion dependent in the hbm.xml editor</b></br><br>
    
<h2>5. Hibernate Console Perspective</h2>

<p>
  The Hibernate Console Perspective combines a set of views which allows
  you to see the structure of your mapped entities/classes, edit HQL queries, execute
  them and see their result. To use this perspective you need to create a console configuration.
</p>

<h3>5.1 Creating a console configuration</h3>

  <p>A console configuration provides enough data for Hibernate
Console to create a Hibernate Configuration object from which a
session factory can be built.</p>

  <p>
    You create a console configuration by running the Console Configuration wizard which is shown in the following figure:
  </p>
    
  <img src="consolecfgwizard.jpg"/>
  <br><b>Figure 2: Creating a Hibernate Console configuration</b></br><br>

    <p>
      Eeach parameter is described in the following table. The
      "Detected default" column is the values the Wizard will automatically
      detect if started when a resource from a Java Project is
      selected.<br></br>

      <table border=1 width=100%>
        <th>Parameter</th><th>Description</th><th>Detected default</th>
          <tr>
            <td>Name</td><td>The unique name of the configuraiton</td><td>Name of the Java project</td>
            </tr>
            <tr>
            <td>Property file</td><td>Path to a property file which is used to create the configuration</td><td>First hibernate.properties file found in the project</td>
            </tr>
            <tr>
            <td>Configuration file</td><td>Path to a hibernate.cfg.xml which is used to create the configuration</td><td>First hibernate.cfg.xml found in the project</td>
            </tr>
            <tr>
            <td>Mapping files</td><td>List of additional mapping files that should be loaded in the configuration. Note: hibernate.cfg.xml can also contain mappings.</td><td>All hbm.xml files found in the project</td>
            </tr>
            <tr>
            <td>Classpath</td><td>The classpath for loading POJO and
            JDBC drivers. Do not add Hibernate related .jars here
            since it will conflict with the Hibernate libraries used
              inside Hibernate Console. This also include any .jars Hibernate is dependent on, such as cglib, commons-logging etc.</td><td>The default build output directory and any .jars that contains a class that implements java.sql.Driver</td>
          </tr>
      </table>
    </p>

    <p>
      When you press "Finish" on the wizard a Console configuration will be created and is visible in the Hibernate Configurations View.
    </p>

<h3>5.2 Viewing the entity structure</h3>

<p>
  To start viewing the entity/class structure you right click the
configuration and select "Create SessionFactory". This will create a
standard Hibernate SessionFactory based on the parameters given in the
console configuration.<br> 

When this have been created a small + should appear next to the named
console configuration. Clicking on this will allow you to browse the
  class/entity structure.</p>

  <p>If an error occur it is probably because of an error in the
console configuration. This will be shown in a message dialog and if
that does not contain enough informationm details about the error and
its exception can be seen in the Error Log view.
</p>

  <img src="queryconsole.jpg"/>
  <br><b>Figure 3: Hibernate Console Perspective showing entity structure, query editor and result</b></br><br>

<h3>5.3 Prototyping Queries</h3>

  <p>Queries can be executed in two ways: by double clicking on entity
  names in the tree or by entering HQL in the HQL editor and pressing
    the green execute button.</p>

    <p>Result of queries will be shown in the Query results view and
    details of possible errors (syntax errors, db errors etc.) is also
    here to be found in the Error Log view.</p>

      <p>Tip: currently the queries will be executed with list() and
      without any limit of the size of the output. Thus be careful
      about executing queries that return a large result. Future
      releases will allow for limiting the result and iterate through
        the result instead.</p>


<h2>6. Reverse engineering and code generation</h2>

  <p>Hibernate Tools 3.0alpha provides a simple "click-and-generate"
  reverse engineering and code generation facility. The reverse
  engineering works by creating a Hibernate Configuration object
  (Hibernates internal meta model). On this meta-model a set of
  (velocity) templates is applied which generates a set of
  artifacts. In this release we have POJO's, hbm.xml's and
  hibernate.cfg.xml generation. To start this you choose the
  "Hibernate Artifact Generation Wizard".</p>

    <h3>6.1 Artifact Generation Wizard</h3>

  <img src="codegenwizard.jpg"/>
  <br><b>Figure 4: Artifact Generation Wizard</b></br><br>

    <p>
      First you need to select which Console configuration will be
      used and in which directory you want the generated code to
      reside. Note: all generation will generate files, and overwrite
      possibly existing files in this location. 
    </p>

    <p>
      Following you have a range of options which are explained in the following.</p>

      <h3>6.1.1 Reverse engineering</h3>

        <p>
           When reverse engineering is selected Hibernate Tools will
           connect to your database and use JDBC metadata to build up
           a Hibernate Configuration.
        </p>      
        
        <p>
          The basic rules for the conversion is that each Table/View
          found is mapped to a Class, and each column is mapped to a
          Property. The package name controls the "root" of the
          generated classes.
        </p>

        <p>
          For each found foreign key, a
          &lt;many-to-one&gt; and a corresponding &lt;one-to-many&gt;
          in a Set is created. 
        </p>
        
        <h4>6.1.1.1 Generate 'raw' composite ids</h4>
        <p>
          The flag "Generate 'raw' composite ids" decides how primary
          keys with multiple keys are handled. There is always created
          a &lt;composite-id&gt;, and if there are matching
          foreign-keys a &lt;key-many-to-one&gt; will be created.
          Except if you choose to active the 'raw' composite ids, then
          it is just treated as a 'raw' scalar value
          (string,long,etc.) instead of a reference to an
          entity. Note: a &lt;many-to-one&gt; property is still
          created, but is simply marked as non-updatable and
          non-insertable.
        </p>

      <h3>6.1.2 Java code generation</h3>
        
        <p>
          The code generation will generate all the persistent classes
          and components found in the Hibernate Configuration.</p>

        <p>
          It is not a requirement to activate reverse
          engineering to use the Java code generation. You can
          use the code generation on your own handwritten or in other ways generated hbm.xml
          files.
        </p>

        <h4>6.1.2.1 EJB3/JSR-220 annotations</h4>

          <p>
            This option will activate any generation of EJB3 sections
            in the javaclass.vm template.  In this release the
            generation are very simple and incomplete. We included
            this option as we expect to send out an update of the
            javaclass.vm template which completes most of this
            generation.  Additionally users can write (and hopefully
            contribute) templates that adds more support for EJB3.
          </p>

          <h4>6.1.2.2 &lt;meta&gt; tag support</h4>

        <p>
          The Java code generation is basically a complete
          rewrite of the hbm2java found in HibernateExt-2.1.3.  This
          means that featurewise they should be very much equal, but
          there might be some exotic &lt;meta&gt; features that is not
          fully implemented yet. If you find such issues are or just
          issues in general we are very much interested in hearing
          about these so they can be fixed in a later release.
        </p>
        
        <p>
          You can read about the &lt;meta&gt; tag feature in the
          existing <a
          href="http://www.hibernate.org/hib_docs/reference/en/html_single/#toolsetguide-s2-2">hbm2java
          documentation</a>
        </p>

      <h3>6.2 Hibernate Mapping file generation</h3>   

        <p>
          This basically dumps a hbm.xml per defined class in the
          configuration. This also goes for inheriance mappings. Each
          &lt;subclass&gt; or &lt;joined-subclass&gt; will be placed
          in a single file with an extends attribute for their superclass.
        </p>

        <p>
          The generation support all the needed features for utilizing
          the reverse engineering functionallity.  Still, not all
          major constructs are supported, and some aspects of the
          hbm.xml is not fully generated yet. We plan to complete this
          in future releases.
        </p>

        <h3>6.3 Hibernate configuration file generation</h3>

          <p>
            This option writes a hibernate.cfg.xml with all hibernate
            relevant properties and with a &lt;mapping&gt; reference
            to each persistent class. This reference will follow the
            same pattern as hibernate mapping file generation - one
            reference per class.
          </p>

      <h3>6.4 Custom templates</h3>

        <p>
          All the code generated are controlled by templates (except
          the hibernate.cfg.xml in this release). These templates are
          per default looked up in the classpath of the Hibernate
          Console Plugin.
        </p>

        <p>
          If something is not generated as you want, or you want
          something completly different you can write your own
          templates and have them used instead. You do this by placing
          your own .vm files in a directory, and tell the Artifact
          Generation Wizard to use custom templates and from which
          directory to look up.
        </p>

        <p>
          There exist a pre-defined set of templates, and to overwrite
          these you need to use the same file names. The pre-defined
          templates can be found in the hibernate-tools.jar found in
          the org.hibernate.eclipse directory.
        </p>

        <p>
          The template names are for the hbm.xml files generation
          named after which section of the hbm.xml they generate
          for. Remember, you don't need to have all templates in your
          custom directory - only for those sections you want to
          change something.
        </p>

        <p>
          The template name for java generation are javaclass.vm. In
          the future this will possibly also be divided into separate
          parts.
        </p>

        <h4>6.4.1 Predefined variables and properties</h4>

          <p>
            All the templates has a predefined set of variables and properties available.
            The following table describe these. 
          </p>

          <table border=1 width='100%'>
            <th>Name</th><th>Contents</th><th>Availability</th>
              <tr>
                <td>$cfg</td><td>The current Hibernate Configuration object. See Hibernate3 javadocs for available properties/methods.</td><td>Anywhere</td>
                </tr>
                <tr>
                <td>$c2h</td><td>A Cfg2HbmTool. Contains a set of helper methods related to cfg to hbm conversion. See sourcecode and existing templates for available properties/methods.</td><td>Anywhere</td>
                </tr>
                <tr>
                <td>$c2j</td><td>A Cfg2JavaTool. Contains a set of helper methods related to cfg to java conversion. See sourcecode and existing templates for available properties/methods.</td><td>Anywhere</td>
                </tr>
                <tr>
                <td>$clazz</td><td>A reference to the current PersistentClass or Component being processed.</td><td>In any class related template</td>
                </tr>
                <tr>
                <td>$property</td><td>A reference to the current Property being processed</td><td>In any property related template</td>
              </tr>
          </table>

          <p>
            Notice that some of these properties are only available in
            a certain context (e.g. $property is not available at the
            Class level, but only when dealing with properties), but
            if you need to look up some information you have full
            access to Hibernate's own meta-model the Configuration via $cfg.
            This combined with the power of velocity templates should
            give you virtually unlimited flexibility and possibilities
            regarding the generation. 
          </p>

          <p>
            Please use it wisely! 
          </p>
          
          <p>
            Enjoy the Hibernate Tools 3.0alpha - The Hibernate Team
          </p>
</body>
</html>

<chapter id="Example2">
<title>Adding Context Menus to Other Views</title>
	<section>
		<title>Goal</title>
			<para>This will be discussed in later examples, but most
			views are representing data, and that data can be of any type.
			How it presents the data is configurable through content providers 
			and label providers, but when looking at the package explore, and
			right-clicking on a java file, you are getting the context menu 
			for that object, which is generated by taking the menu options
			provided by the view, as well as those provided for any object 
			of that type. A .java file is an IResource type in the JDT model, so any
			actions provided for those types will be shown	in the menu. </para>
			
			<para> The goal for this example is to add two different types of 
			context menus. One menu will be added 
			to a specific view, and the other will be added when certain
			types of objects inside a view are clicked upon.</para>
			
	</section>


	<section>
		<title>Create the Plugin</title>
		<para>Select <literal>File</literal>-&gt;
		<literal>new</literal>-&gt;<literal>other...</literal> and Plug-in Project.
		Name this project <literal>Example2ContextMenus</literal>. We won't use any 
		template for this example, though the basic plugin class will still be 
		generated for you.</para>
		
		<para>Next, create a new package by right-clicking on the <literal>src</literal> 
		directory and selecting <literal>New-&gt;Package</literal>. Name this
		package <literal>example2ContextMenus.actions</literal>.</para>
		
		<para>Create a new class by right-clicking on that package and selecting
		<literal>New-&gt;Class</literal>. Name this class 
		<literal>ContextAction1.java</literal> and complete it as follows:</para>
		<programlisting>package example2ContextMenus.actions;

/* assorted import statements removed for brevity */

public class ContextAction1 implements IViewActionDelegate {

	public void run(IAction action) {
		MessageDialog.openInformation(
			new Shell(),
			"Example2 Action 1",
			"Hello, Eclipse world Action 1");
	}

	public void selectionChanged(IAction action, ISelection selection) {
	}

	public void dispose() {
	}

	public void init(IViewPart view) {
		// Used for viewerContributions, not for objectContributions
	}
}</programlisting>
		
		<para>
			The <literal>IActionDelegate</literal> interface provides a method 
			<literal>selectionChanged</literal>, which allows the action to know
			what is selected, or, in other words, what object this action 
			is acting upon. Since we are just popping up a dialog box, 
			the selection does not matter at all, however if you were 
			implementing an action that would delete some item from an underlying
			model, you would need to keep a reference to that selection. 
		</para>
	</section>
	
<section><title>Creating a popup with an ObjectContribution</title>	
	
	<section>
		<title>Creating the Extension</title>
		<para>The next step is to add this information to a context menu somewhere, 
		so that the action can actually be invoked. This is done through the 
		plugin.xml file or its gui editor. We will want our new menu to appear
		when right-clicking on a file in any view, such as 
		the resource view or the package explorer view. The class
		for this is IFile, and is located in the org.eclipse.core.resources plug-in. </para>
		
		<para>So, first go to the <literal>extensions</literal> tab for the gui editor
		to the <literal>plugin.xml</literal> file. Next, click add, and select
		<literal>org.eclipse.ui.popupMenus</literal> from the list. We will NOT
		use template provided. Click <literal>finish</literal>.</para>
		
		<para>In the gui editor, right click on the new extension and select 
		<literal>new-&gt;objectContribution</literal>. On the right, set the 
		id field to <literal>Example2ContextMenus.popups.ifileContribution</literal>
		and the objectClass field to <literal>org.eclipse.core.resources.IFile</literal>.</para>
		
		<para>Under that, we'll make a menu and an action.
		To create the menu, right click on our objectContribution and select
		<literal>new-&gt;menu</literal> set the id to Example2ContextMenus.menu1
		and the label to IDE Extension Tutorial. Right click on the new menu and 
		select <literal>new-&gt;separator</literal> to create a separator in our menu.
		Set the name of this separator to group1.</para>
		
		<para>Set the values as follows:
		id = Example2ContextMenus.action1, 
		label = Action 1, 
		menubarPath = Example2ContextMenus.menu1/group1, 
		class = example2ContextMenus.actions.ContextAction1</para>

		<informaltable frame="none">
			<tgroup cols="2" align="left" colsep="0" rowsep="0">
				<tbody>
					<row>
						<entry valign="top">
						
		
		<para>As you can see, the class is the same one we created earlier,
		and the menubarPath matches the separator we made just a few seconds ago.</para>
		
		<para>When done, save the file. The extension tree should now look like this.</para>
		
		</entry>
		<entry><mediaobject><imageobject>
				<imagedata align="center" fileref="images/lab2_extensions.gif"/>
		</imageobject></mediaobject></entry>
</row></tbody></tgroup></informaltable>
		
		
		
	</section>

	<section>
		<title>Testing</title>
		<para>The first thing is to run the application much as you did in the last
		example. This menu won't appear until you right-click on a file inside
		the runtime environment, though, so once the workbench is running, we'll 
		need to create a project and some files. First I created a 
		simple text file (<literal>file-&lt;new-&lt;File</literal>).
		I also created a Test.java file and added a few 
		dummy methods via the following code:</para>

		<informaltable frame="none">
			<tgroup cols="2" align="left" colsep="0" rowsep="0">
				<tbody>
					<row>
						<entry valign="top">
		<programlisting>public class Test {
	private int myInt;
	public Test() {
		this.myInt = 1;
	}
	public int someInt() {
		return myInt;
	}
	public static String someString() {
		return "HelloWorld";
	}
}</programlisting>
<para>Once this code is added, your expanded package explorer view
should look like the one to the right.</para>

		</entry>
		<entry><mediaobject><imageobject>
				<imagedata align="center" fileref="images/lab2_runtime_test.gif"/>
		</imageobject></mediaobject></entry>
</row></tbody></tgroup></informaltable>

	</section>
	<section><title>Results</title>
	<para>
		Now, if we right click on Test.java, on someString(), myInt,Test(), or someInt()
		in the package explorer, our menu will not be added. If we wanted our
		menus to appear there, our objectContribution would have needed to be
		an objectClass of IResource for the Test.java element, IMember for a method or 
		field, IField for just a field, IMethod for just a method, etc. If you HAD 
		used one of these class types for our object contribution, our menu
		element would appear when right-clicking on an element of that type
		in ANY view. So if we had used IField, it would appear both in the 
		package explorer and the outline views. 
		If we instead right-click on test.file in the package explorer
		view, our menu addition DOES appear.
	</para>
	
	<para>
		If we then load up the Navigator view (<literal>window-&gt;show view-&gt;Navigator</literal>),
		clicking on either test.file OR test.java will result in our menu being shown.
		The reason for this is how that view keeps track of the objects in their model. Navigator 
		represents everything as IFiles, whereas the package explorer and the outline
		views represent elements as members of JDT when possible (IMethod, IField, IResource),
		and IFiles when not possible. 
	</para>

		</section>
		
		
</section>

<section><title>Creating a popup with a ViewerContribution</title>
	<section>
		<title>Creation</title>
		<para>
			Right-click on our popupMenus extension and select 
			<literal>new-&gt;viewerContribution</literal>.
			Set the id to <literal>Example2ContextMenus.viewerContribution2</literal> and the 
			targetID to <literal>org.eclipse.ui.views.TaskList</literal></para>.
			
			<para>This targetID designates the id of the extension point
			that our extension matches. For this example, our menu
			will appear in the task list, another view which keeps track of
			all of the TODO's in your java code. </para>
			
			<para>To the viewerContribution, add a menu with an id of
			<literal>Example2ContextMenus.menu2</literal>, and a label of 
			<literal>IDE Extension viewerContrib</literal>. Give the menu,
			add a separator named <literal>group2</literal>.</para>
			
			<para>To our viewer contribution, add an action.
			Give the action an id of <literal>Example2ContextMenus.action3</literal>,
			a label of <literal>Viewer Contrib Action</literal>, 
			a class of <literal>example2ContextMenus.actions.ContextAction1</literal> 
			(which is the same action as in the objectContribution), and a 
			menubarPath of <literal>Example2ContextMenus.menu2/group2</literal>.</para>
			
			<para>Then save the file.</para>
	</section>
	
	<section>
		<title>Testing this Extension</title>
		<para>Run the program the same way as before, by right-clicking on
		the project and selecting <literal>Run As-&gt;Eclipse Application</literal>.
		Once the runtime environment has loaded, open the Task List view by selecting
		<literal>Window-&gt;Show View-&gt;Tasks</literal>. Then try right-clicking
		inside the view. The menu option should appear, as shown below.</para>
		<mediaobject><imageobject>
				<imagedata align="center" fileref="images/lab2_viewer_contrib.gif"/>
		</imageobject></mediaobject>
	</section>
</section>

<section><title>Example Conclusions</title>
	<para>
		Object contributions to popup menus are easy to implement, but they 
		require knowing how the plugin you're adding a menu item to stores
		its data. As we saw earlier, the Navigator view stores a file as 
		an IFile, whereas the Package Explorer will try to convert a java file
		into an ICompilationUnit. 
	</para>
	<para>
		Viewer contributions, on the other hand, require you to know
		the id name of the viewer where you want your menu to appear. This
		could involve digging through the code of that plug-in to discover 
		the id of the viewer. 
	</para>
	
	<para>
		One thing we did not do with the menus was visibility, which can be 
		added to either an objectcontribution or a viewercontribution. 
		Visibility allows you to use some basic parameters (such as 
		object class, object state, plugin state, or system property) 
		and some simple boolean conjunctions, to more finely tune 
		which elements will show your menu and which will not. I encourage
		you to play around with sub-elements to the popupMenu extension point.
	</para>
</section>

</chapter>